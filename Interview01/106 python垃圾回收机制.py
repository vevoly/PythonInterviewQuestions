# _*_ coding: utf-8 _*_
__author__ = 'jevoly'
__date__ = '2019/2/16 0016 下午 11:45'
"""
python垃圾回收主要以引用计数为主，标记-清除和分代清除为辅的机制，
其中标记-清除和分代回收主要是为了处理循环引用的难题。

引用计数算法：
当有1个变量保存了对象的应用时，此对象的引用计数就会加1
当使用del删除变量指向的对象时，如果对象引用计数不为1，
比如3，那么此时只会让这个引用计数减1，即变成2，当再次调用
del时，变为1， 如果再调用1次del，此时会真的把对象进行删除。
"""

"""
import sys sys.getrefcount()查看引用计数 字符串中间有空格！？等会重新创建新的字符串 总结

小整数[-5,257)共用对象，常驻内存，不会被释放。
单个字符共用对象，常驻内存。
单个单词，不可修改，默认开启intern机制，共用对象，引用计数为0，则销毁 。
大整数不共用内存，引用计数为0，销毁 .
数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象 . Garbage collection(GC垃圾回收) python采用的是引用计数机制为主，标记-清除和分代收集(隔代回收、分代回收)两种机制为辅的策略
引用计数机制的优点： 1、简单

2、实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。 引用计数机制的缺点： 维护引用计数消耗资源 循环引用，解决不了

gc模块 3.1. 垃圾回收机制 导致引用计数+1的情况 1.对象被创建，例如a = "hello" 2.对象被引用，例如b=a 3.对象被作为参数，传入到一个函数中，例如func(a) 4.对象作为一个元素，存储在容器中，例如list1=[a,a]

常用函数 1、gc.set_debug(flags) 设置gc的debug日志，一般设置为gc.DEBUG_LEAK 2、gc.collect([generation]) 显式进行垃圾回收，可以输入参数，0代表只检查零代的对象，1代表检查零，一代的对象，2代表检查零，一，二代的对象，如果不传参数，执行一个full collection，也就是等于传2。 在python2中返回不可达（unreachable objects）对象的数目 3、gc.get_threshold() 获取的gc模块中自动执行垃圾回收的频率。 4、gc.set_threshold(threshold0[, threshold1[, threshold2]) 设置自动执行垃圾回收的频率。 5、gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表 Python的GC模块主要运用了引用计数来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”解决容器对象可能产生的循环引用的问题。通过分代回收以空间换取时间进一步提高垃圾回收的效率。
标记-清除 标记-清除的出现打破了循环引用，也就是它只关注那些可能会产生循环引用的对象 缺点：该机制所带来的额外操作和需要回收的内存块成正比。 一旦这个差异累计超过某个阈值(700,10,10)，则Python的收集机制就启动了，并且触发上边所说到的零代算法释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。

隔代回收 原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。
--------------------- 
作者：python宝典 
来源：CSDN 
原文：https://blog.csdn.net/ZhangQiye1993/article/details/81231618 
版权声明：本文为博主原创文章，转载请附上博文链接！

"""